:py:mod:`pytomography.classes`
==============================

.. py:module:: pytomography.classes


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pytomography.classes.ObjectMeta
   pytomography.classes.ImageMeta
   pytomography.classes.CTCorrectionNet
   pytomography.classes.PSFCorrectionNet
   pytomography.classes.ForwardProjectionNet
   pytomography.classes.BackProjectionNet
   pytomography.classes.OSEMNet
   pytomography.classes.SmoothnessPriorOSL
   pytomography.classes.QuadraticPriorOSL
   pytomography.classes.CompareToNumber



Functions
~~~~~~~~~

.. autoapisummary::

   pytomography.classes.rev_cumsum
   pytomography.classes.rotate_detector_z
   pytomography.classes.get_prob_of_detection_matrix
   pytomography.classes.get_distance
   pytomography.classes.get_PSF_transform
   pytomography.classes.find_first_entry_containing_substring
   pytomography.classes.simind_projections_to_data
   pytomography.classes.simind_CT_to_data
   pytomography.classes.get_osem_net



.. py:function:: rev_cumsum(x)


.. py:function:: rotate_detector_z(x, angle, interpolation=InterpolationMode.BILINEAR, negative=False)


.. py:function:: get_prob_of_detection_matrix(CT, dx)


.. py:function:: get_distance(N, r, dx)


.. py:function:: get_PSF_transform(sigma, kernel_size, delta=1e-09, device='cpu', kernel_dimensions='2D')


.. py:function:: find_first_entry_containing_substring(list_of_attributes, substring, dtype=np.float32)


.. py:function:: simind_projections_to_data(headerfile)


.. py:function:: simind_CT_to_data(headerfile)


.. py:function:: get_osem_net(projections_header, object_initial='ones', CT_header=None, PSF_options=None, device='cpu')


.. py:class:: ObjectMeta(dx, shape)


.. py:class:: ImageMeta(object_meta, angles, radii=None)


.. py:class:: CTCorrectionNet(object_meta, image_meta, CT, store_in_memory=False, device='cpu')

   Bases: :py:obj:`torch.nn.Module`

   Apply attenuation correction to an object.

   Given projection along the x-axis, an object is modified
   using an array of CT values such that subsequent projection
   yields an appropriate image

   .. py:method:: forward(object_i, i, norm_constant=None)

      Modify object using attenuation correction.

      :param object_i: This object is such that summation along the x-axis yields the ith projection in
                       the image
      :type object_i: (batch_size, Lx, Ly, Lz) torch.tensor
      :param i: The projection index
      :type i: number
      :param norm_constant: If true, modify the norm_constant argument by the normalization factor
                            used to scale object_i. This is useful during back projection, where division by
                            a normalization constant is required.
      :type norm_constant: (batch_size, Lx, Ly, Lz) torch.tensor. Default: None
      :param Returns: Pytorch tensor of size [batch_size, Lx, Ly, Lz] cor



.. py:class:: PSFCorrectionNet(object_meta, image_meta, collimator_slope, collimator_intercept, kernel_size=21, kernel_dimensions='2D', device='cpu')

   Bases: :py:obj:`torch.nn.Module`

   Base class for all neural network modules.

   Your models should also subclass this class.

   Modules can also contain other Modules, allowing to nest them in
   a tree structure. You can assign the submodules as regular attributes::

       import torch.nn as nn
       import torch.nn.functional as F

       class Model(nn.Module):
           def __init__(self):
               super().__init__()
               self.conv1 = nn.Conv2d(1, 20, 5)
               self.conv2 = nn.Conv2d(20, 20, 5)

           def forward(self, x):
               x = F.relu(self.conv1(x))
               return F.relu(self.conv2(x))

   Submodules assigned in this way will be registered, and will have their
   parameters converted too when you call :meth:`to`, etc.

   .. note::
       As per the example above, an ``__init__()`` call to the parent class
       must be made before assignment on the child.

   :ivar training: Boolean represents whether this module is in training or
                   evaluation mode.
   :vartype training: bool

   .. py:method:: get_sigma(radius, dx, shape, collimator_slope, collimator_intercept)


   .. py:method:: forward(object_i, i, norm_constant=None)



.. py:class:: ForwardProjectionNet(object_correction_nets, image_correction_nets, object_meta, image_meta, device='cpu')

   Bases: :py:obj:`torch.nn.Module`

   Base class for all neural network modules.

   Your models should also subclass this class.

   Modules can also contain other Modules, allowing to nest them in
   a tree structure. You can assign the submodules as regular attributes::

       import torch.nn as nn
       import torch.nn.functional as F

       class Model(nn.Module):
           def __init__(self):
               super().__init__()
               self.conv1 = nn.Conv2d(1, 20, 5)
               self.conv2 = nn.Conv2d(20, 20, 5)

           def forward(self, x):
               x = F.relu(self.conv1(x))
               return F.relu(self.conv2(x))

   Submodules assigned in this way will be registered, and will have their
   parameters converted too when you call :meth:`to`, etc.

   .. note::
       As per the example above, an ``__init__()`` call to the parent class
       must be made before assignment on the child.

   :ivar training: Boolean represents whether this module is in training or
                   evaluation mode.
   :vartype training: bool

   .. py:method:: forward(object, angle_subset=None)



.. py:class:: BackProjectionNet(object_correction_nets, image_correction_nets, object_meta, image_meta, device='cpu')

   Bases: :py:obj:`torch.nn.Module`

   Base class for all neural network modules.

   Your models should also subclass this class.

   Modules can also contain other Modules, allowing to nest them in
   a tree structure. You can assign the submodules as regular attributes::

       import torch.nn as nn
       import torch.nn.functional as F

       class Model(nn.Module):
           def __init__(self):
               super().__init__()
               self.conv1 = nn.Conv2d(1, 20, 5)
               self.conv2 = nn.Conv2d(20, 20, 5)

           def forward(self, x):
               x = F.relu(self.conv1(x))
               return F.relu(self.conv2(x))

   Submodules assigned in this way will be registered, and will have their
   parameters converted too when you call :meth:`to`, etc.

   .. note::
       As per the example above, an ``__init__()`` call to the parent class
       must be made before assignment on the child.

   :ivar training: Boolean represents whether this module is in training or
                   evaluation mode.
   :vartype training: bool

   .. py:method:: forward(image, angle_subset=None, prior=None, delta=1e-11)



.. py:class:: OSEMNet(object_initial, forward_projection_net, back_projection_net, prior=None)

   Bases: :py:obj:`torch.nn.Module`

   Base class for all neural network modules.

   Your models should also subclass this class.

   Modules can also contain other Modules, allowing to nest them in
   a tree structure. You can assign the submodules as regular attributes::

       import torch.nn as nn
       import torch.nn.functional as F

       class Model(nn.Module):
           def __init__(self):
               super().__init__()
               self.conv1 = nn.Conv2d(1, 20, 5)
               self.conv2 = nn.Conv2d(20, 20, 5)

           def forward(self, x):
               x = F.relu(self.conv1(x))
               return F.relu(self.conv2(x))

   Submodules assigned in this way will be registered, and will have their
   parameters converted too when you call :meth:`to`, etc.

   .. note::
       As per the example above, an ``__init__()`` call to the parent class
       must be made before assignment on the child.

   :ivar training: Boolean represents whether this module is in training or
                   evaluation mode.
   :vartype training: bool

   .. py:method:: get_subset_splits(n_subsets, n_angles)


   .. py:method:: set_image(image)


   .. py:method:: set_prior(prior)


   .. py:method:: forward(n_iters, n_subsets, comparisons=None, delta=1e-11)



.. py:class:: SmoothnessPriorOSL(beta, phi, delta=1, device='cpu')

   Bases: :py:obj:`torch.nn.Module`

   Base class for all neural network modules.

   Your models should also subclass this class.

   Modules can also contain other Modules, allowing to nest them in
   a tree structure. You can assign the submodules as regular attributes::

       import torch.nn as nn
       import torch.nn.functional as F

       class Model(nn.Module):
           def __init__(self):
               super().__init__()
               self.conv1 = nn.Conv2d(1, 20, 5)
               self.conv2 = nn.Conv2d(20, 20, 5)

           def forward(self, x):
               x = F.relu(self.conv1(x))
               return F.relu(self.conv2(x))

   Submodules assigned in this way will be registered, and will have their
   parameters converted too when you call :meth:`to`, etc.

   .. note::
       As per the example above, an ``__init__()`` call to the parent class
       must be made before assignment on the child.

   :ivar training: Boolean represents whether this module is in training or
                   evaluation mode.
   :vartype training: bool

   .. py:method:: get_kernel()


   .. py:method:: set_object(object)


   .. py:method:: forward()



.. py:class:: QuadraticPriorOSL(beta, device='cpu')

   Bases: :py:obj:`SmoothnessPriorOSL`

   Base class for all neural network modules.

   Your models should also subclass this class.

   Modules can also contain other Modules, allowing to nest them in
   a tree structure. You can assign the submodules as regular attributes::

       import torch.nn as nn
       import torch.nn.functional as F

       class Model(nn.Module):
           def __init__(self):
               super().__init__()
               self.conv1 = nn.Conv2d(1, 20, 5)
               self.conv2 = nn.Conv2d(20, 20, 5)

           def forward(self, x):
               x = F.relu(self.conv1(x))
               return F.relu(self.conv2(x))

   Submodules assigned in this way will be registered, and will have their
   parameters converted too when you call :meth:`to`, etc.

   .. note::
       As per the example above, an ``__init__()`` call to the parent class
       must be made before assignment on the child.

   :ivar training: Boolean represents whether this module is in training or
                   evaluation mode.
   :vartype training: bool


.. py:class:: CompareToNumber(number, mask, norm_factor=None)

   .. py:method:: compare(prediction)



